---
// Glowing Connections Background
// Subtle animated lines connecting floating points - represents connectivity
---

<canvas id="connections-canvas" aria-hidden="true"></canvas>

<script>
  function initConnections() {
    const canvas = document.getElementById('connections-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      canvas.style.display = 'none';
      return;
    }

    // Brand colors with low opacity
    const colors = [
      'rgba(126, 199, 134, 0.4)',  // green
      'rgba(95, 176, 196, 0.4)',   // teal
      'rgba(240, 192, 92, 0.3)',   // amber
      'rgba(78, 234, 181, 0.35)',  // mint
    ];

    interface Point {
      x: number;
      y: number;
      vx: number;
      vy: number;
      baseX: number;
      baseY: number;
    }

    interface Connection {
      start: number;
      end: number;
      progress: number;
      speed: number;
      color: string;
      active: boolean;
      fadeIn: boolean;
      opacity: number;
      width: number;
    }

    let points: Point[] = [];
    let connections: Connection[] = [];
    let animationId: number;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initPoints();
    }

    function initPoints() {
      points = [];
      const numPoints = Math.floor((canvas.width * canvas.height) / 80000); // Sparse distribution
      const minPoints = 8;
      const maxPoints = 20;
      const count = Math.max(minPoints, Math.min(maxPoints, numPoints));

      for (let i = 0; i < count; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        points.push({
          x,
          y,
          baseX: x,
          baseY: y,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
        });
      }
    }

    function createConnection() {
      if (points.length < 2) return;

      const start = Math.floor(Math.random() * points.length);
      let end = Math.floor(Math.random() * points.length);
      while (end === start) {
        end = Math.floor(Math.random() * points.length);
      }

      // Check if connection already exists
      const exists = connections.some(
        c => c.active && ((c.start === start && c.end === end) || (c.start === end && c.end === start))
      );
      if (exists) return;

      connections.push({
        start,
        end,
        progress: 0,
        speed: 0.003 + Math.random() * 0.004,
        color: colors[Math.floor(Math.random() * colors.length)],
        active: true,
        fadeIn: true,
        opacity: 0,
        width: 1 + Math.random() * 1.5,
      });
    }

    function drawPoint(x: number, y: number, color: string, size: number = 3) {
      ctx!.beginPath();
      ctx!.arc(x, y, size, 0, Math.PI * 2);
      ctx!.fillStyle = color;
      ctx!.fill();

      // Glow effect
      const gradient = ctx!.createRadialGradient(x, y, 0, x, y, size * 4);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, 'transparent');
      ctx!.beginPath();
      ctx!.arc(x, y, size * 4, 0, Math.PI * 2);
      ctx!.fillStyle = gradient;
      ctx!.fill();
    }

    function drawConnection(conn: Connection) {
      const p1 = points[conn.start];
      const p2 = points[conn.end];

      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;

      // Draw the line with progress
      const currentX = p1.x + dx * conn.progress;
      const currentY = p1.y + dy * conn.progress;

      ctx!.beginPath();
      ctx!.moveTo(p1.x, p1.y);
      ctx!.lineTo(currentX, currentY);

      // Apply opacity
      const colorWithOpacity = conn.color.replace(/[\d.]+\)$/, `${conn.opacity * 0.6})`);
      ctx!.strokeStyle = colorWithOpacity;
      ctx!.lineWidth = conn.width;
      ctx!.lineCap = 'round';
      ctx!.stroke();

      // Glowing head at the current position
      if (conn.progress > 0 && conn.progress < 1) {
        const glowColor = conn.color.replace(/[\d.]+\)$/, `${conn.opacity})`);
        drawPoint(currentX, currentY, glowColor, 2);
      }
    }

    function animate() {
      ctx!.clearRect(0, 0, canvas.width, canvas.height);

      // Slowly move points
      points.forEach(point => {
        point.x += point.vx;
        point.y += point.vy;

        // Gentle pull back to base position
        point.vx += (point.baseX - point.x) * 0.0005;
        point.vy += (point.baseY - point.y) * 0.0005;

        // Damping
        point.vx *= 0.99;
        point.vy *= 0.99;

        // Wrap around edges
        if (point.x < -50) point.x = canvas.width + 50;
        if (point.x > canvas.width + 50) point.x = -50;
        if (point.y < -50) point.y = canvas.height + 50;
        if (point.y > canvas.height + 50) point.y = -50;
      });

      // Draw subtle point indicators
      points.forEach(point => {
        drawPoint(point.x, point.y, 'rgba(255, 255, 255, 0.15)', 2);
      });

      // Update and draw connections
      connections.forEach(conn => {
        if (!conn.active) return;

        // Fade in
        if (conn.fadeIn) {
          conn.opacity += 0.02;
          if (conn.opacity >= 1) {
            conn.opacity = 1;
            conn.fadeIn = false;
          }
        }

        // Progress the line
        conn.progress += conn.speed;

        // Start fading out near the end
        if (conn.progress > 0.7) {
          conn.opacity -= 0.015;
        }

        // Remove when done
        if (conn.progress >= 1 || conn.opacity <= 0) {
          conn.active = false;
        }

        drawConnection(conn);
      });

      // Clean up inactive connections
      connections = connections.filter(c => c.active);

      // Randomly create new connections
      if (Math.random() < 0.008 && connections.length < 4) {
        createConnection();
      }

      animationId = requestAnimationFrame(animate);
    }

    // Initialize
    resize();
    window.addEventListener('resize', resize);

    // Start with a couple connections
    setTimeout(() => createConnection(), 500);
    setTimeout(() => createConnection(), 1500);

    animate();

    // Cleanup on motion preference change
    window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {
      if (e.matches) {
        cancelAnimationFrame(animationId);
        canvas.style.display = 'none';
      }
    });
  }

  // Initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initConnections);
  } else {
    initConnections();
  }
</script>

<style>
  #connections-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    pointer-events: none;
    opacity: 0.7;
  }
</style>
