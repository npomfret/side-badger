---
// Gentle shooting stars + micro fireworks background
// Inspired by research/ui-research/interaction/motion-feedback.md guidance on subtle, GPU-friendly motion with reduced-motion fallbacks.
---

<canvas id="shooting-stars-canvas" aria-hidden="true"></canvas>

<script>
  type RGB = { r: number; g: number; b: number };

  const STAR_PALETTE: RGB[] = [
    { r: 240, g: 253, b: 244 },
    { r: 134, g: 239, b: 172 },
    { r: 74, g: 222, b: 128 },
  ];

  const FIREWORK_COLORS: RGB[] = [
    { r: 255, g: 255, b: 255 },
    { r: 210, g: 255, b: 229 },
    { r: 180, g: 255, b: 205 },
  ];

  const rand = (min: number, max: number) => Math.random() * (max - min) + min;

  class AmbientStar {
    x: number;
    y: number;
    radius: number;
    twinkleSpeed: number;
    phase: number;
    color: RGB;

    constructor(width: number, height: number) {
      this.color = STAR_PALETTE[Math.floor(Math.random() * STAR_PALETTE.length)];
      this.reset(width, height);
      this.twinkleSpeed = rand(0.00015, 0.0006);
      this.phase = Math.random() * Math.PI * 2;
    }

    reset(width: number, height: number) {
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.radius = rand(0.6, 1.8);
    }

    draw(ctx: CanvasRenderingContext2D, time: number) {
      const twinkle = 0.35 + 0.45 * Math.sin(time * this.twinkleSpeed + this.phase);
      ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${Math.max(0, twinkle)})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  class ShootingStar {
    x: number;
    y: number;
    velocityX: number;
    velocityY: number;
    length: number;
    thickness: number;
    life: number;
    maxLife: number;

    constructor(width: number, height: number) {
      this.x = rand(width * 0.1, width * 0.9);
      this.y = rand(height * 0.05, height * 0.35);
      const speed = rand(600, 900);
      const angle = rand(Math.PI * 0.1, Math.PI * 0.25);
      this.velocityX = Math.cos(angle) * speed;
      this.velocityY = Math.sin(angle) * speed;
      this.length = rand(90, 150);
      this.thickness = rand(1.4, 2.5);
      this.life = rand(0.8, 1.6);
      this.maxLife = this.life;
    }

    update(delta: number) {
      this.x += this.velocityX * delta;
      this.y += this.velocityY * delta;
      this.life -= delta;
    }

    isAlive(width: number, height: number) {
      return (
        this.life > 0 &&
        this.x + this.length > 0 &&
        this.y - this.length < height &&
        this.x - this.length < width
      );
    }

    draw(ctx: CanvasRenderingContext2D) {
      const tailX = this.x - this.velocityX * (this.length / 900);
      const tailY = this.y - this.velocityY * (this.length / 900);
      const gradient = ctx.createLinearGradient(tailX, tailY, this.x, this.y);
      gradient.addColorStop(0, 'rgba(34, 197, 94, 0)');
      gradient.addColorStop(0.5, 'rgba(134, 239, 172, 0.4)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');

      ctx.strokeStyle = gradient;
      ctx.lineWidth = this.thickness;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(tailX, tailY);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();

      ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.thickness * 1.8, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  class FireworkParticle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    maxLife: number;
    size: number;
    color: RGB;

    constructor(x: number, y: number) {
      const speed = rand(60, 120);
      const angle = rand(0, Math.PI * 2);
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;
      this.x = x;
      this.y = y;
      this.life = rand(0.7, 1.2);
      this.maxLife = this.life;
      this.size = rand(1.4, 2.4);
      this.color = FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)];
    }

    update(delta: number) {
      this.x += this.vx * delta;
      this.y += this.vy * delta;
      this.vy += 15 * delta; // gentle gravity
      this.life -= delta;
      this.vx *= 0.98;
      this.vy *= 0.98;
    }

    isAlive() {
      return this.life > 0;
    }

    draw(ctx: CanvasRenderingContext2D) {
      const opacity = Math.max(0, this.life / this.maxLife);
      ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  class CelestialRenderer {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private stars: AmbientStar[] = [];
    private shootingStars: ShootingStar[] = [];
    private fireworks: FireworkParticle[] = [];
    private animationId: number | null = null;
    private lastTime = 0;
    private nextShootingStar = 0;
    private nextFirework = 0;
    private resizeHandler: () => void;
    private motionQuery: MediaQueryList;
    private motionHandler: (event: MediaQueryListEvent) => void;
    private isReducedMotion: boolean;

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d')!;
      this.motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      this.isReducedMotion = this.motionQuery.matches;
      this.motionHandler = (event) => {
        this.isReducedMotion = event.matches;
        if (this.isReducedMotion) {
          this.stop();
          this.drawStatic();
        } else {
          this.lastTime = performance.now();
          this.start();
        }
      };
      this.motionQuery.addEventListener('change', this.motionHandler);
      this.resizeHandler = () => this.handleResize();
      window.addEventListener('resize', this.resizeHandler, { passive: true });
      this.handleResize();
    }

    private handleResize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      this.canvas.width = window.innerWidth * dpr;
      this.canvas.height = window.innerHeight * dpr;
      this.canvas.style.width = '100%';
      this.canvas.style.height = '100%';
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.scale(dpr, dpr);
      const starCount = Math.round((window.innerWidth * window.innerHeight) / 18000);
      this.stars = Array.from({ length: starCount }, () => new AmbientStar(window.innerWidth, window.innerHeight));
      if (this.isReducedMotion) {
        this.drawStatic();
      }
    }

    private drawBackground() {
      const gradient = this.ctx.createLinearGradient(0, 0, 0, window.innerHeight);
      gradient.addColorStop(0, 'rgba(10, 25, 17, 0.75)');
      gradient.addColorStop(1, 'rgba(5, 12, 9, 0.85)');
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    }

    private drawStatic() {
      this.drawBackground();
      const now = performance.now();
      this.stars.forEach((star) => star.draw(this.ctx, now));
    }

    private spawnShootingStar() {
      this.shootingStars.push(new ShootingStar(window.innerWidth, window.innerHeight));
    }

    private spawnFirework() {
      const x = rand(window.innerWidth * 0.2, window.innerWidth * 0.8);
      const y = rand(window.innerHeight * 0.2, window.innerHeight * 0.5);
      const particleCount = 12;
      for (let i = 0; i < particleCount; i++) {
        this.fireworks.push(new FireworkParticle(x, y));
      }
    }

    private animate = (timestamp: number) => {
      if (this.isReducedMotion) {
        this.drawStatic();
        return;
      }

      if (!this.lastTime) this.lastTime = timestamp;
      const delta = (timestamp - this.lastTime) / 1000;
      this.lastTime = timestamp;

      this.drawBackground();

      this.stars.forEach((star) => star.draw(this.ctx, timestamp));

      if (timestamp > this.nextShootingStar) {
        this.spawnShootingStar();
        this.nextShootingStar = timestamp + rand(4000, 8000);
      }

      if (timestamp > this.nextFirework) {
        this.spawnFirework();
        this.nextFirework = timestamp + rand(8000, 14000);
      }

      this.shootingStars = this.shootingStars.filter((star) => {
        star.update(delta);
        star.draw(this.ctx);
        return star.isAlive(window.innerWidth, window.innerHeight);
      });

      this.fireworks = this.fireworks.filter((particle) => {
        particle.update(delta);
        particle.draw(this.ctx);
        return particle.isAlive();
      });

      this.animationId = requestAnimationFrame(this.animate);
    };

    start() {
      if (this.isReducedMotion) {
        this.drawStatic();
        return;
      }
      if (!this.animationId) {
        this.lastTime = performance.now();
        this.animationId = requestAnimationFrame(this.animate);
      }
    }

    stop() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }

    destroy() {
      this.stop();
      window.removeEventListener('resize', this.resizeHandler);
      this.motionQuery.removeEventListener('change', this.motionHandler);
    }
  }

  const canvas = document.getElementById('shooting-stars-canvas') as HTMLCanvasElement | null;
  if (canvas) {
    const renderer = new CelestialRenderer(canvas);
    renderer.start();
    document.addEventListener('astro:before-swap', () => {
      renderer.destroy();
    }, { once: true });
  }
</script>

<style>
  #shooting-stars-canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: var(--z-background, -1);
    mix-blend-mode: screen;
    opacity: 0.65;
  }

  @media (prefers-reduced-motion: reduce) {
    #shooting-stars-canvas {
      opacity: 0.5;
    }
  }
</style>
