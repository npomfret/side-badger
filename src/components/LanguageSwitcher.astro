---
import { allLocales, localeNames, localeFlagCodes, getFlagUrl, getPathWithoutLocale, t, resolveLocale, localeAliases, type Locale, type LocaleOrAlias, type DropdownLocale } from '../i18n';

interface Props {
  currentLocale: Locale;
  currentPath: string;
}

const { currentLocale, currentPath } = Astro.props;
const changeLanguageLabel = t('a11y.changeLanguage', currentLocale);
const searchLanguagesLabel = t('a11y.searchLanguages', currentLocale);

// Extract the actual locale/alias from the URL path to display the correct variant
function getDisplayLocaleFromPath(path: string): DropdownLocale {
  // Check if the path starts with any locale alias (e.g., /en-us/, /en-gb/)
  for (const alias of localeAliases) {
    if (path.startsWith(`/${alias}/`) || path === `/${alias}`) {
      return alias;
    }
  }
  // For non-English locales, check the dropdown locales
  for (const loc of allLocales) {
    if (path.startsWith(`/${loc}/`) || path === `/${loc}`) {
      return loc;
    }
  }
  // Default: if no locale prefix (root path), default to en-gb
  return 'en-gb';
}

const displayLocale = getDisplayLocaleFromPath(currentPath);

// Get the path without any locale prefix
const basePath = getPathWithoutLocale(currentPath);

// Parse locale name into main part and parenthetical subtitle
function parseLocaleName(name: string): { main: string; subtitle?: string } {
  const match = name.match(/^(.+?)\s*\((.+)\)$/);
  if (match) {
    return { main: match[1], subtitle: match[2] };
  }
  return { main: name };
}

// Prepare locale data for the template (includes comedy aliases)
const localeData = allLocales.map(locale => {
  const parsed = parseLocaleName(localeNames[locale]);
  return {
    code: locale,
    name: localeNames[locale],
    mainName: parsed.main,
    subtitle: parsed.subtitle,
    flagUrl: getFlagUrl(localeFlagCodes[locale]),
    href: `/${locale}${basePath === '/' ? '' : basePath}`,
    active: resolveLocale(locale) === currentLocale,
  };
});

const searchPlaceholder = t('languageSwitcher.search', currentLocale);
const noResultsText = t('languageSwitcher.noResults', currentLocale);

// Parse the current display locale name for the button
const currentParsed = parseLocaleName(localeNames[displayLocale]);
---

<div class="language-switcher">
  <button class="language-switcher-btn" aria-label={changeLanguageLabel} aria-expanded="false" aria-haspopup="listbox">
    <img class="current-flag" src={getFlagUrl(localeFlagCodes[displayLocale])} alt="" loading="eager" />
    <span class="current-lang">
      {currentParsed.main}
      {currentParsed.subtitle && <span class="current-subtitle">{currentParsed.subtitle}</span>}
    </span>
    <svg class="chevron" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <path d="m6 9 6 6 6-6"/>
    </svg>
  </button>
  <div class="language-dropdown">
    <div class="language-search-wrapper">
      <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <circle cx="11" cy="11" r="8"/>
        <path d="m21 21-4.3-4.3"/>
      </svg>
      <input
        type="text"
        class="language-search"
        placeholder={searchPlaceholder}
        autocomplete="off"
        aria-label={searchLanguagesLabel}
      />
    </div>
    <div class="language-options" role="listbox" aria-label={changeLanguageLabel}>
      {localeData.map((locale) => (
        <a
          href={locale.href}
          class:list={['language-option', { active: locale.active }]}
          data-locale={locale.code}
          data-name={locale.name.toLowerCase()}
          role="option"
          aria-selected={locale.active ? 'true' : 'false'}
          lang={locale.code.split('-')[0]}
        >
          <img class="option-flag" src={locale.flagUrl} alt="" loading="lazy" />
          <span class="option-name">
            {locale.mainName}
            {locale.subtitle && <span class="option-subtitle">{locale.subtitle}</span>}
          </span>
        </a>
      ))}
    </div>
    <div class="no-results" style="display: none;">
      {noResultsText}
    </div>
  </div>
</div>

<script>
  const LOCALE_KEY = 'preferred-locale';

  // Reorder options based on browser language preferences
  function prioritizeUserLanguages(optionsContainer: Element) {
    const options = Array.from(optionsContainer.querySelectorAll('.language-option')) as HTMLElement[];
    const browserLangs = navigator.languages || [navigator.language];

    // Normalize browser languages (e.g., 'en-US' -> 'en-us', 'de' -> 'de')
    const normalizedBrowserLangs = browserLangs.map(lang => lang.toLowerCase());

    // Sort: matching languages first (in browser preference order), then rest alphabetically
    const prioritized: HTMLElement[] = [];
    const rest: HTMLElement[] = [];

    options.forEach(option => {
      const locale = option.getAttribute('data-locale') || '';
      const langBase = locale.split('-')[0]; // 'en-us' -> 'en', 'de' -> 'de'

      // Check if this locale matches any browser language
      const matchIndex = normalizedBrowserLangs.findIndex(browserLang =>
        browserLang === locale ||
        browserLang.startsWith(locale + '-') ||
        browserLang === langBase ||
        locale.startsWith(browserLang + '-')
      );

      if (matchIndex !== -1) {
        // Store with priority index for sorting
        (option as any)._priority = matchIndex;
        prioritized.push(option);
      } else {
        rest.push(option);
      }
    });

    // Sort prioritized by browser preference order
    prioritized.sort((a, b) => (a as any)._priority - (b as any)._priority);

    // Reorder DOM
    [...prioritized, ...rest].forEach(option => {
      optionsContainer.appendChild(option);
    });
  }

  document.querySelectorAll('.language-switcher').forEach(switcher => {
    // Prioritize languages based on browser settings
    const optionsContainer = switcher.querySelector('.language-options');
    if (optionsContainer) {
      prioritizeUserLanguages(optionsContainer);
    }
    const btn = switcher.querySelector('.language-switcher-btn');
    const dropdown = switcher.querySelector('.language-dropdown');
    const searchInput = switcher.querySelector('.language-search') as HTMLInputElement;
    const options = switcher.querySelectorAll('.language-option');
    const noResults = switcher.querySelector('.no-results');

    const openDropdown = () => {
      btn?.setAttribute('aria-expanded', 'true');
      switcher.classList.add('open');

      // Focus search input when opening (but not on touch devices to avoid keyboard popup)
      if (searchInput && !('ontouchstart' in window)) {
        setTimeout(() => searchInput.focus(), 100);
      }
    };

    const closeDropdown = () => {
      btn?.setAttribute('aria-expanded', 'false');
      switcher.classList.remove('open');
    };

    // Toggle dropdown
    btn?.addEventListener('click', (e) => {
      e.stopPropagation();
      const isExpanded = btn.getAttribute('aria-expanded') === 'true';
      if (isExpanded) {
        closeDropdown();
      } else {
        openDropdown();
      }
    });

    // Filter languages as user types
    searchInput?.addEventListener('input', (e) => {
      const query = (e.target as HTMLInputElement).value.toLowerCase().trim();
      let visibleCount = 0;

      options.forEach(option => {
        const name = option.getAttribute('data-name') || '';
        const locale = option.getAttribute('data-locale') || '';
        const matches = name.includes(query) || locale.includes(query);

        (option as HTMLElement).style.display = matches ? '' : 'none';
        if (matches) visibleCount++;
      });

      // Show/hide no results message
      if (noResults) {
        (noResults as HTMLElement).style.display = visibleCount === 0 ? 'block' : 'none';
      }
    });

    // Prevent dropdown from closing when clicking inside
    dropdown?.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Store preference when selecting a language
    options.forEach(option => {
      option.addEventListener('click', () => {
        const locale = option.getAttribute('data-locale');
        if (locale) {
          localStorage.setItem(LOCALE_KEY, locale);
        }
      });
    });

    // Clear search when dropdown closes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          if (!switcher.classList.contains('open') && searchInput) {
            searchInput.value = '';
            options.forEach(option => {
              (option as HTMLElement).style.display = '';
            });
            if (noResults) {
              (noResults as HTMLElement).style.display = 'none';
            }
          }
        }
      });
    });
    observer.observe(switcher, { attributes: true });
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', () => {
    document.querySelectorAll('.language-switcher').forEach(switcher => {
      switcher.classList.remove('open');
      switcher.querySelector('button')?.setAttribute('aria-expanded', 'false');
    });
    document.body.style.overflow = '';
  });
</script>

<style>
  @import '../styles/language-switcher.css';
</style>
