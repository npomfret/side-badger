---
// Caustic Ripples Background Component
// Creates underwater light refraction effect using Canvas 2D + Perlin noise
---

<canvas id="caustic-canvas"></canvas>

<script>
  // Simple Perlin noise implementation
  class PerlinNoise {
    constructor() {
      this.permutation = [];
      for (let i = 0; i < 256; i++) {
        this.permutation[i] = Math.floor(Math.random() * 256);
      }
      this.permutation = [...this.permutation, ...this.permutation];
    }

    fade(t: number): number {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }

    lerp(a: number, b: number, t: number): number {
      return a + t * (b - a);
    }

    grad(hash: number, x: number, y: number): number {
      const h = hash & 3;
      const u = h < 2 ? x : y;
      const v = h < 2 ? y : x;
      return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }

    noise(x: number, y: number): number {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = this.fade(x);
      const v = this.fade(y);
      const A = this.permutation[X] + Y;
      const B = this.permutation[X + 1] + Y;
      return this.lerp(
        this.lerp(this.grad(this.permutation[A], x, y), this.grad(this.permutation[B], x - 1, y), u),
        this.lerp(this.grad(this.permutation[A + 1], x, y - 1), this.grad(this.permutation[B + 1], x - 1, y - 1), u),
        v
      );
    }
  }

  // Caustic renderer
  class CausticRenderer {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private noise: PerlinNoise;
    private time: number = 0;
    private animationId: number | null = null;
    private isReducedMotion: boolean;

    // Colors from tokens (green/teal/amber) - boosted opacity
    private colors = [
      { r: 126, g: 199, b: 134, a: 0.35 }, // aurora-green
      { r: 95, g: 176, b: 196, a: 0.28 },  // aurora-teal
      { r: 240, g: 192, b: 92, a: 0.20 },  // aurora-amber
    ];

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d')!;
      this.noise = new PerlinNoise();
      this.isReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      this.resize();
      window.addEventListener('resize', () => this.resize());

      // Listen for motion preference changes
      window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {
        this.isReducedMotion = e.matches;
        if (e.matches) {
          this.stop();
          this.drawStatic();
        } else {
          this.start();
        }
      });
    }

    resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      this.canvas.width = window.innerWidth * dpr;
      this.canvas.height = window.innerHeight * dpr;
      this.canvas.style.width = '100%';
      this.canvas.style.height = '100%';
      this.ctx.scale(dpr, dpr);
    }

    drawCaustics() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      // Clear with transparent
      this.ctx.clearRect(0, 0, width, height);

      // Draw caustic layers
      const scale = 0.003; // Noise scale
      const timeScale = 0.00005; // Very slow animation (15-20 second cycle feel)

      for (let layer = 0; layer < 3; layer++) {
        const color = this.colors[layer];
        const layerOffset = layer * 100;
        const layerTime = this.time * (1 + layer * 0.3);

        // Create gradient patches
        for (let x = 0; x < width; x += 40) {
          for (let y = 0; y < height; y += 40) {
            const noiseVal = this.noise.noise(
              (x + layerOffset) * scale + layerTime * timeScale,
              (y + layerOffset) * scale + layerTime * timeScale * 0.7
            );

            // Only draw bright spots (caustic highlights)
            if (noiseVal > 0.2) {
              const intensity = (noiseVal - 0.2) * 1.5;
              const size = 30 + intensity * 60;

              const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, size);
              gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a * intensity})`);
              gradient.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a * intensity * 0.3})`);
              gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

              this.ctx.fillStyle = gradient;
              this.ctx.fillRect(x - size, y - size, size * 2, size * 2);
            }
          }
        }
      }

      // Add subtle overall blur effect via compositing
      this.ctx.globalCompositeOperation = 'lighter';
      this.ctx.filter = 'blur(20px)';
      this.ctx.drawImage(this.canvas, 0, 0, width, height);
      this.ctx.filter = 'none';
      this.ctx.globalCompositeOperation = 'source-over';
    }

    drawStatic() {
      // Draw a single frame for reduced motion
      this.time = 5000; // Fixed time for consistent look
      this.drawCaustics();
    }

    animate = () => {
      this.time += 16.67; // ~60fps timestep
      this.drawCaustics();
      this.animationId = requestAnimationFrame(this.animate);
    }

    start() {
      if (this.isReducedMotion) {
        this.drawStatic();
        return;
      }
      if (!this.animationId) {
        this.animate();
      }
    }

    stop() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
    }
  }

  // Initialize
  const canvas = document.getElementById('caustic-canvas') as HTMLCanvasElement;
  if (canvas) {
    const renderer = new CausticRenderer(canvas);
    renderer.start();

    // Cleanup on page navigation (for Astro view transitions)
    document.addEventListener('astro:before-swap', () => {
      renderer.stop();
    });
  }
</script>

<style>
  #caustic-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: var(--z-background, -1);
    pointer-events: none;
    opacity: 1;
  }
</style>
